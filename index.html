<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Haro by avoidwork</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Haro</h1>
      <h2 class="project-tagline">Harō is modern DataStore that can be wired to an API</h2>
      <a href="https://github.com/avoidwork/haro" class="btn">View on GitHub</a>
      <a href="https://github.com/avoidwork/haro/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/avoidwork/haro/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="haro" class="anchor" href="#haro" aria-hidden="true"><span class="octicon octicon-link"></span></a>haro</h1>

<p><a href="https://gitter.im/avoidwork/haro?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/avoidwork/haro"></a></p>

<p><a href="http://travis-ci.org/avoidwork/haro"><img src="https://secure.travis-ci.org/avoidwork/haro.svg" alt="build status"></a></p>

<p>Harō is a modern immutable DataStore built with ES6 features, which can be wired to an API for a complete feedback loop.
It is un-opinionated, and offers a plug'n'play solution to modeling, searching, &amp; managing data on the client, or server
(in RAM). It is a <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">partially persistent data structure</a>, by maintaining version sets of records in <code>versions</code> (<a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a>).</p>

<p>Synchronous commands return instantly (<code>Array</code> or <code>Tuple</code>), while asynchronous commands return  <code>Promises</code> which will
resolve or reject in the future. This allows you to build complex applications without worrying about managing async 
code.</p>

<p>Harō indexes have the following structure <code>Map (field/property) &gt; Map (value) &gt; Set (PKs)</code> which allow for quick &amp; easy 
searching, as well as inspection. Indexes can be managed independently of <code>del()</code> &amp; <code>set()</code> operations, for example you 
can lazily create new indexes via <code>reindex(field)</code>, or <code>sortBy(field)</code>.</p>

<h3>
<a id="requirements" class="anchor" href="#requirements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements</h3>

<p>Harō is built with ES6+ features, and requires polyfills for ES5 or earlier environments.</p>

<ul>
<li><code>Map</code></li>
<li><code>Set</code></li>
<li><code>Promise</code></li>
<li><code>fetch()</code></li>
<li>
<code>deferred()</code> see <a href="https://github.com/avoidwork/tiny-defer">tiny-defer</a> for loading in a browser</li>
<li>
<code>tuple()</code> see <a href="https://github.com/avoidwork/tiny-tuple">tiny-tuple</a> for loading in a browser</li>
</ul>

<h3>
<a id="how-to-use" class="anchor" href="#how-to-use" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to use</h3>

<p>Harō takes two optional arguments, the first is an <code>Array</code> of records to set asynchronously, &amp; the second is a 
configuration descriptor.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> storeDefaults <span class="pl-k">=</span> haro();
<span class="pl-k">var</span> storeRecords <span class="pl-k">=</span> haro([{name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">30</span>}, {name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">28</span>}]);
<span class="pl-k">var</span> storeCustom <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>});</pre></div>

<h3>
<a id="persistent-storage" class="anchor" href="#persistent-storage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Persistent Storage</h3>

<p>Harō is an in RAM only DataStore, so state could be lost if your program unexpectedly restarted, or some kind of 
machine failure were to occur. To handle this serious problem, Harō affords a 1-n relationship with persistent storage 
adapters. You can register one or many adapters, and data updates will asynchronously persist to the various long term 
storage systems.</p>

<p>DataStore records will be stored separate of the DataStore snapshot itself (if you decide to leverage it), meaning you 
are responsible for doing a <code>load()</code> &amp; <code>save()</code> at startup &amp; shutdown. This is a manual process because it could be a 
time bottleneck in the middle of using your application. Loading an individual record will update the DataStore with 
value from persistent storage.</p>

<p>DataStore snapshots &amp; individual records can be removed from persistent storage with <code>unload()</code>; it is not recommended 
to do this for an individual record, and to instead rely on <code>del()</code>, but it's afforded because it may be required.</p>

<h4>
<a id="creating-an-adapter" class="anchor" href="#creating-an-adapter" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating an Adapter</h4>

<p>Adapters are simple in nature (can be isomorphic), and pretty easy to create! Follow the template below, fill in the 
gaps for your adapter as needed, such as handling multiple connection pools, etc.. The input parameters should not be 
mutated. The return must be a <code>Promise</code>.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">const</span> <span class="pl-c1">deferred</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">"</span>tiny-defer<span class="pl-pds">"</span></span>);

<span class="pl-k">function</span> <span class="pl-en">adapter</span> (<span class="pl-smi">store</span>, <span class="pl-smi">op</span>, <span class="pl-smi">key</span>, <span class="pl-smi">data</span>) {
    <span class="pl-k">let</span> defer <span class="pl-k">=</span> deferred(),
        record <span class="pl-k">=</span> key <span class="pl-k">!==</span> <span class="pl-c1">undefined</span>,
        config <span class="pl-k">=</span> store.adapters.myAdapterName,
        prefix <span class="pl-k">=</span> config.<span class="pl-c1">prefix</span> <span class="pl-k">||</span> store.<span class="pl-c1">id</span>,
        lkey <span class="pl-k">=</span> prefix <span class="pl-k">+</span> (record <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">"</span>_<span class="pl-pds">"</span></span> <span class="pl-k">+</span> key <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)),
        client <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Your driver instance<span class="pl-pds">"</span></span>;

    <span class="pl-k">if</span> (op <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span>get<span class="pl-pds">"</span></span>) {
        client.get(lkey, <span class="pl-k">function</span> (<span class="pl-smi">e</span>, <span class="pl-smi">reply</span>) {
            <span class="pl-k">let</span> result <span class="pl-k">=</span> <span class="pl-c1">JSON</span>.<span class="pl-c1">parse</span>(reply <span class="pl-k">||</span> <span class="pl-c1">null</span>);

            <span class="pl-k">if</span> (e) {
                defer.reject(e);
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (result) {
                defer.resolve(result);
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (record) {
                defer.reject(<span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">"</span>Record not found in myAdapterName<span class="pl-pds">"</span></span>));
            } <span class="pl-k">else</span> {
                defer.reject([]);
            }
        });
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (op <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span>remove<span class="pl-pds">"</span></span>) {
        client.del(lkey, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
            <span class="pl-k">if</span> (e) {
                defer.reject(e);
            } <span class="pl-k">else</span> {
                defer.resolve(<span class="pl-c1">true</span>);
            }
        });
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (op <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span>set<span class="pl-pds">"</span></span>) {
        client.set(lkey, <span class="pl-c1">JSON</span>.stringify(record <span class="pl-k">?</span> data <span class="pl-k">:</span> store.toArray()), <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
            <span class="pl-k">if</span> (e) {
                defer.reject(e);
            } <span class="pl-k">else</span> {
                defer.resolve(<span class="pl-c1">true</span>);
            }
        });
    }

    <span class="pl-k">return</span> defer.promise;
}

<span class="pl-c1">module</span>.exports <span class="pl-k">=</span> adapter;</pre></div>

<h3>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h3>

<h4>
<a id="piping-promises" class="anchor" href="#piping-promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Piping Promises</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

<span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.total); <span class="pl-c">// 0</span>

store.set(<span class="pl-c1">null</span>, {abc<span class="pl-k">:</span> <span class="pl-c1">true</span>}).then(<span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(arg); <span class="pl-c">// [$uuid, {abc: true}];</span>
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.total); <span class="pl-c">// 1</span>
  <span class="pl-k">return</span> store.set(arg[<span class="pl-c1">0</span>], {abc<span class="pl-k">:</span> <span class="pl-c1">false</span>});
}).then(<span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(arg); <span class="pl-c">// [$uuid, {abc: false}];</span>
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.versions.get(arg[<span class="pl-c1">0</span>]).<span class="pl-c1">size</span>); <span class="pl-c">// 1;</span>
  <span class="pl-k">return</span> store.del(arg[<span class="pl-c1">0</span>])
}).then(<span class="pl-k">function</span> () {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.total); <span class="pl-c">// 0;</span>
}).catch(<span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<h4>
<a id="indexes--searching" class="anchor" href="#indexes--searching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Indexes &amp; Searching</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span>]}),
    data <span class="pl-k">=</span> [{name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">30</span>}, {name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">28</span>}];

store.batch(data, <span class="pl-s"><span class="pl-pds">'</span>set<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(records[<span class="pl-c1">0</span>]); <span class="pl-c">// [$uuid, {name: 'John Doe', age: 30}]</span>
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.total); <span class="pl-c">// 2</span>
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.<span class="pl-c1">find</span>({age<span class="pl-k">:</span> <span class="pl-c1">28</span>})); <span class="pl-c">// [[$uuid, {name: 'Jane Doe', age: 28}]]</span>
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.<span class="pl-c1">search</span>(<span class="pl-sr"><span class="pl-pds">/</span><span class="pl-k">^</span>ja<span class="pl-pds">/</span>i</span>, <span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>)); <span class="pl-c">// [[$uuid, {name: 'Jane Doe', age: 28}]]</span>
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.<span class="pl-c1">search</span>(<span class="pl-k">function</span> (<span class="pl-smi">age</span>) { <span class="pl-k">return</span> age <span class="pl-k">&lt;</span> <span class="pl-c1">30</span>; }, <span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span>)); <span class="pl-c">// [[$uuid, {name: 'Jane Doe', age: 28}]]</span>
}).catch(<span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<h4>
<a id="mvcc-versioning" class="anchor" href="#mvcc-versioning" aria-hidden="true"><span class="octicon octicon-link"></span></a>MVCC versioning</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

store.set(<span class="pl-c1">null</span>, {abc<span class="pl-k">:</span> <span class="pl-c1">true</span>}).then(<span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  <span class="pl-k">return</span> store.set(arg[<span class="pl-c1">0</span>], {abc<span class="pl-k">:</span> <span class="pl-c1">false</span>});
}).then(<span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  <span class="pl-k">return</span> store.set(arg[<span class="pl-c1">0</span>], {abc<span class="pl-k">:</span> <span class="pl-c1">true</span>});
}).then(<span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  store.versions.get(arg[<span class="pl-c1">0</span>]).forEach(<span class="pl-k">function</span> (<span class="pl-smi">i</span>) { <span class="pl-en">console</span>.<span class="pl-c1">log</span>(i[<span class="pl-c1">0</span>]); }); <span class="pl-c">// {abc: true}, {abc: false}</span>
}).catch(<span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<h3>
<a id="benchmarked" class="anchor" href="#benchmarked" aria-hidden="true"><span class="octicon octicon-link"></span></a>Benchmarked</h3>

<p>A benchmark is included in the repository, and is useful for gauging how haro will perform on different hardware, &amp; software.
Please consider that <code>batch()</code>, &amp; <code>set()</code> use <code>Promises</code> and incur time as a cost. The following results are from an Apple
MacBook Air (Early 2014) / 8GB RAM / 512GB SSD / OS X Yosemite:</p>

<pre><code>time to load data: 523.421068ms
datastore record count: 15000
name indexes: 15000
testing time to 'find()' a record (first one is cold):
0.31272ms
0.123786ms
0.051086ms
0.053974ms
0.045515ms
testing time to 'search(regex, index)' for a record (first one is cold):
2.676046ms
1.760155ms
2.087627ms
1.558766ms
1.568192ms
</code></pre>

<h3>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration</h3>

<p><strong>adapters</strong>
<em>Object</em></p>

<p>Object of {(storage): (connection string)} pairs. Collection/table name is the value of <code>this.id</code>.</p>

<p>Available adapters: <em>mongo</em></p>

<p>Example of specifying MongoDB as persistent storage:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {
  adapters<span class="pl-k">:</span> {
    mongo<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>mongo://localhost/mine<span class="pl-pds">"</span></span>
  }
});</pre></div>

<p><strong>config</strong>
<em>Object</em></p>

<p>Default settings for <code>fetch()</code>.</p>

<p>Example of specifying a bearer token authorization header:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {
  config<span class="pl-k">:</span> {
    headers<span class="pl-k">:</span> {
      authorization<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Bearer abcdef<span class="pl-pds">'</span></span>
    }
  });</pre></div>

<p><strong>index</strong>
<em>Array</em></p>

<p>Array of values to index. Composite indexes are supported, by using the default delimiter (<code>this.delimiter</code>).
Non-matches within composites result in blank values.</p>

<p>Example of fields/properties to index:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>field1<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>field2<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>field1|field2|field3<span class="pl-pds">'</span></span>]);</pre></div>

<p><strong>key</strong>
<em>String</em></p>

<p>Optional <code>Object</code> key to utilize as <code>Map</code> key, defaults to a version 4 <code>UUID</code> if not specified, or found.</p>

<p>Example of specifying the primary key:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>field<span class="pl-pds">'</span></span>});</pre></div>

<p><strong>logging</strong>
<em>Boolean</em></p>

<p>Logs persistent storage messages to <code>console</code>, default is <code>true</code>.</p>

<p><strong>onbatch</strong>
<em>Function</em></p>

<p>Event listener for a batch operation, receives two arguments ['type', <code>Tuple</code>].</p>

<p><strong>onclear</strong>
<em>Function</em></p>

<p>Event listener for clearing the data store.</p>

<p><strong>ondelete</strong>
<em>Function</em></p>

<p>Event listener for when a record is deleted, receives the record key.</p>

<p><strong>onerror</strong>
<em>Function</em></p>

<p>Event listener for errors which occur during common operations, receives two arguments ['type', <code>Error</code>]</p>

<p><strong>onset</strong>
<em>Function</em></p>

<p>Event listener for when a record is set, receives a <code>Tuple</code>.</p>

<p><strong>onsync</strong>
<em>Function</em></p>

<p>Event listener for synchronizing with an API, receives a <code>Tuple</code> of <code>Tuples</code>.</p>

<p><strong>source</strong>
<em>String</em></p>

<p>Optional <code>Object</code> key to retrieve data from API responses, see <code>setUri()</code>.</p>

<p>Example of specifying the source of data:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {source<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>data<span class="pl-pds">'</span></span>});</pre></div>

<p><strong>versioning</strong>
<em>Boolean</em></p>

<p>Enable/disable MVCC style versioning of records, default is <code>true</code>. Versions are stored in <code>Sets</code> for easy iteration.</p>

<p>Example of disabling versioning:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {versioning<span class="pl-k">:</span> <span class="pl-c1">false</span>});</pre></div>

<h3>
<a id="properties" class="anchor" href="#properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Properties</h3>

<p><strong>data</strong>
<em>Map</em></p>

<p><code>Map</code> of records, updated by <code>del()</code> &amp; <code>set()</code>.</p>

<p><strong>indexes</strong>
<em>Map</em></p>

<p>Map of indexes, which are Sets containing Map keys.</p>

<p><strong>patch</strong>
<em>Boolean</em></p>

<p>Set from the success handler of <code>sync()</code>, infers <code>PATCH</code> requests are supported by the API collection.</p>

<p><strong>registry</strong>
<em>Array</em></p>

<p>Array representing the order of <code>this.data</code>.</p>

<p><strong>total</strong>
<em>Number</em></p>

<p>Total records in the DataStore.</p>

<p><strong>uri</strong>
<em>String</em></p>

<p>API collection URI the DataStore is wired to, in a feedback loop (do not modify, use <code>setUri()</code>). Setting the value creates an implicit relationship with records, e.g. setting <code>/users</code> would imply a URI structure of <code>/users/{key}</code>. Trailing slashes may be stripped.</p>

<p><strong>versions</strong>
<em>Map</em></p>

<p><code>Map</code> of <code>Sets</code> of records, updated by <code>set()</code>.</p>

<h3>
<a id="api" class="anchor" href="#api" aria-hidden="true"><span class="octicon octicon-link"></span></a>API</h3>

<p><strong>batch(array, type)</strong>
<em>Promise</em></p>

<p>The first argument must be an <code>Array</code>, and the second argument must be <code>del</code> or <code>set</code>. Batch operations with a DataStore 
that is wired to an API with pagination enabled &amp; <code>PATCH</code> support may create erroneous operations, such as <code>add</code> where
<code>replace</code> is appropriate; this will happen because the DataStore will not have the entire data set to generate it's 
<a href="http://jsonpatchjs.com/">JSONPatch</a> request.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> haro <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>haro<span class="pl-pds">'</span></span>),
    store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>, index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>]}),
    i <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>,
    nth <span class="pl-k">=</span> <span class="pl-c1">100</span>,
    data <span class="pl-k">=</span> [];

<span class="pl-k">while</span> (<span class="pl-k">++</span>i <span class="pl-k">&lt;</span> nth) {
  data.<span class="pl-c1">push</span>({id<span class="pl-k">:</span> i, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span> <span class="pl-k">+</span> i});
}

store.batch(data, <span class="pl-s"><span class="pl-pds">'</span>set<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span>(<span class="pl-smi">records</span>) {
  <span class="pl-c">// records is a Tuple of Tuples</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack);
});</pre></div>

<p><strong>clear()</strong>
<em>self</em></p>

<p>Removes all key/value pairs from the DataStore.</p>

<p>Example of clearing a DataStore:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

<span class="pl-c">// Data is added</span>

store.<span class="pl-c1">clear</span>();</pre></div>

<p><strong>del(key)</strong>
<em>Promise</em></p>

<p>Deletes the record.</p>

<p>Example of deleting a record:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

store.set(<span class="pl-c1">null</span>, {abc<span class="pl-k">:</span> <span class="pl-c1">true</span>}).then(<span class="pl-k">function</span> (<span class="pl-smi">rec</span>) {
  <span class="pl-k">return</span> store.del(rec[<span class="pl-c1">0</span>]);
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-k">throw</span> e;
}).then(<span class="pl-k">function</span> () {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.total); <span class="pl-c">// 0</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack);
});</pre></div>

<p><strong>dump(type="records")</strong>
<em>Array</em> or <em>Object</em></p>

<p>Returns the records or indexes of the DataStore as mutable <code>Array</code> or <code>Object</code>, for the intention of reuse/persistent storage without relying on an adapter which would break up the data set.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

<span class="pl-c">// Data is loaded</span>

<span class="pl-k">var</span> records <span class="pl-k">=</span> store.<span class="pl-c1">dump</span>();
<span class="pl-k">var</span> indexes <span class="pl-k">=</span> store.<span class="pl-c1">dump</span>(<span class="pl-s"><span class="pl-pds">'</span>indexes<span class="pl-pds">'</span></span>);

<span class="pl-c">// Save records &amp; indexes</span></pre></div>

<p><strong>entries()</strong>
<em>MapIterator</em></p>

<p>Returns returns a new <code>Iterator</code> object that contains an array of <code>[key, value]</code> for each element in the <code>Map</code> object in 
insertion order.</p>

<p>Example of deleting a record:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(),
    item, iterator;

<span class="pl-c">// Data is added</span>

iterator <span class="pl-k">=</span> store.entries();
item <span class="pl-k">=</span> iterator.<span class="pl-c1">next</span>();

<span class="pl-k">do</span> {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(item.<span class="pl-c1">value</span>);
  item <span class="pl-k">=</span> iterator.<span class="pl-c1">next</span>();
} <span class="pl-k">while</span> (<span class="pl-k">!</span>item.done);</pre></div>

<p><strong>filter(callbackFn)</strong>
<em>Tuple</em></p>

<p>Returns a <code>Tuple</code> of double <code>Tuples</code> with the shape <code>[key, value]</code> for records which returned <code>true</code> to 
<code>callbackFn(value, key)</code>.</p>

<p>Example of filtering a DataStore:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

<span class="pl-c">// Data is added</span>

store.filter(<span class="pl-k">function</span> (<span class="pl-smi">value</span>) {
  <span class="pl-k">return</span> value.something <span class="pl-k">===</span> <span class="pl-c1">true</span>;
});</pre></div>

<p><strong>find(where)</strong>
<em>Tuple</em></p>

<p>Returns a <code>Tuple</code> of double <code>Tuples</code> with found by indexed values matching the <code>where</code>.</p>

<p>Example of finding a record(s) with an identity match:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>field1<span class="pl-pds">'</span></span>]});

<span class="pl-c">// Data is added</span>

store.<span class="pl-c1">find</span>({field1<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>some value<span class="pl-pds">'</span></span>});</pre></div>

<p><strong>forEach(callbackFn[, thisArg])</strong>
<em>Undefined</em></p>

<p>Calls <code>callbackFn</code> once for each key-value pair present in the <code>Map</code> object, in insertion order. If a <code>thisArg</code> 
parameter is provided to <code>forEach</code>, it will be used as the this value for each callback.</p>

<p>Example of deleting a record:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

store.set(<span class="pl-c1">null</span>, {abc<span class="pl-k">:</span> <span class="pl-c1">true</span>}).then(<span class="pl-k">function</span> (<span class="pl-smi">rec</span>) {
  store.forEach(<span class="pl-k">function</span> (<span class="pl-smi">value</span>, <span class="pl-smi">key</span>) {
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(key);
  });
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack);
});</pre></div>

<p><strong>get(key)</strong>
<em>Tuple</em></p>

<p>Gets the record as a double <code>Tuple</code> with the shape <code>[key, value]</code>.</p>

<p>Example of getting a record with a known primary key value:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

<span class="pl-c">// Data is added</span>

store.get(<span class="pl-s"><span class="pl-pds">'</span>keyValue<span class="pl-pds">'</span></span>);</pre></div>

<p><strong>join(other, on[, type="inner"])</strong>
<em>Array</em></p>

<p>Joins <code>this</code> instance of <code>Haro</code> with another, on a field/property. Supports "inner", "left", &amp; "right" joins. Resulting 
composite records implement a <code>storeId_field</code> convention for fields/properties.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store1 <span class="pl-k">=</span> haro([{id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>jason<span class="pl-pds">"</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">35</span>}, {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>def<span class="pl-pds">"</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>jen<span class="pl-pds">"</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">31</span>}], {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>users<span class="pl-pds">'</span></span>, key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>, index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span>]});
<span class="pl-k">var</span> store2 <span class="pl-k">=</span> haro([{id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>ghi<span class="pl-pds">'</span></span>, user<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, value<span class="pl-k">:</span> <span class="pl-c1">40</span>}], {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>values<span class="pl-pds">'</span></span>, key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>, index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>user<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>value<span class="pl-pds">'</span></span>]});

<span class="pl-c">// Join results</span>
store1.<span class="pl-c1">join</span>(store2, <span class="pl-s"><span class="pl-pds">"</span>user<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>inner<span class="pl-pds">"</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(records);
  <span class="pl-c">// [{"users_id":"abc","users_name":"jason","users_age":35,"values_id":"ghi","values_user":"abc","values_value":40}]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});

store1.<span class="pl-c1">join</span>(store2, <span class="pl-s"><span class="pl-pds">"</span>user<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>left<span class="pl-pds">"</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(records);
  <span class="pl-c">// [{"users_id":"abc","users_name":"jason","users_age":35,"values_id":"ghi","values_user":"abc","values_value":40},</span>
  <span class="pl-c">//  {"users_id":"def","users_name":"jen","users_age":31,"values_id":null,"values_user":null,"values_value":null}]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});

store1.<span class="pl-c1">join</span>(store2, <span class="pl-s"><span class="pl-pds">"</span>user<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>right<span class="pl-pds">"</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(records);
  <span class="pl-c">// [{"values_id":"ghi","values_user":"abc","values_value":40,"users_id":"abc","users_name":"jason","users_age":35}]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});
</pre></div>

<p><strong>keys()</strong>
<em>MapIterator</em></p>

<p>Returns a new <code>Iterator</code> object that contains the keys for each element in the <code>Map</code> object in insertion order.`</p>

<p>Example of getting an iterator, and logging the results:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(),
    item, iterator;

<span class="pl-c">// Data is added</span>

iterator <span class="pl-k">=</span> store.keys();
item <span class="pl-k">=</span> iterator.<span class="pl-c1">next</span>();

<span class="pl-k">do</span> {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(item.<span class="pl-c1">value</span>);
  item <span class="pl-k">=</span> iterator.<span class="pl-c1">next</span>();
} <span class="pl-k">while</span> (<span class="pl-k">!</span>item.done);</pre></div>

<p><strong>limit(max, offset=0)</strong>
<em>Tuple</em></p>

<p>Returns a <code>Tuple</code> of double <code>Tuples</code> with the shape <code>[key, value]</code> for the corresponding range of records.</p>

<p>Example of paginating a data set:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(), ds1, ds2;

<span class="pl-c">// Data is added</span>

<span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.total); <span class="pl-c">// &gt;10</span>
ds1 <span class="pl-k">=</span> store.limit(<span class="pl-c1">10</span>);     <span class="pl-c">// [0-9]</span>
ds2 <span class="pl-k">=</span> store.limit(<span class="pl-c1">10</span>, <span class="pl-c1">10</span>); <span class="pl-c">// [10-19]</span>

<span class="pl-en">console</span>.<span class="pl-c1">log</span>(ds1.<span class="pl-c1">length</span> <span class="pl-k">===</span> ds2.<span class="pl-c1">length</span>); <span class="pl-c">// true</span>
<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-c1">JSON</span>.stringify(ds1[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>]) <span class="pl-k">===</span> <span class="pl-c1">JSON</span>.stringify(ds2[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>])); <span class="pl-c">// false</span></pre></div>

<p><strong>load([adapter="mongo", key])</strong>
<em>Promise</em></p>

<p>Loads the DataStore, or a record from a specific persistent storage &amp; updates the DataStore. The DataStore will be cleared 
prior to loading if <code>key</code> is omitted.</p>

<p><strong>map(callbackFn)</strong>
<em>Tuple</em></p>

<p>Returns a <code>Tuple</code> of the returns of <code>callbackFn(value, key)</code>.</p>

<p>Example of mapping a DataStore:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

<span class="pl-c">// Data is added</span>

store.map(<span class="pl-k">function</span> (<span class="pl-smi">value</span>) {
  <span class="pl-k">return</span> value.property;
});</pre></div>

<p><strong>offload(data[, cmd="index", index=this.index])</strong>
<em>Promise</em></p>

<p>Returns a <code>Promise</code> for an offloaded work load, such as preparing indexes in a <code>Worker</code>. This method is ideal for dealing 
with large data sets which could block a UI thread. This method requires <code>Blob</code> &amp; <code>Worker</code>. </p>

<p>Example of offloading index creation:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span>], key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>guid<span class="pl-pds">'</span></span>}),
    data <span class="pl-k">=</span> [{guid<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jason Mulligan<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">35</span>}];

store.offload(data).then(<span class="pl-k">function</span> (<span class="pl-smi">args</span>) {
  store.override(data);
  store.override(args, <span class="pl-s"><span class="pl-pds">'</span>indexes<span class="pl-pds">'</span></span>);
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e);
});</pre></div>

<p><strong>override(data[, type="records", fn])</strong>
<em>Promise</em></p>

<p>Returns a <code>Promise</code> for the new state. This is meant to be used in a paired override of the indexes &amp; records, such that
you can avoid the <code>Promise</code> based code path of a <code>batch()</code> insert or <code>load()</code>. Accepts an optional third parameter to perform the
transformation to simplify cross domain issues.</p>

<p>Example of overriding a DataStore:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

store.override({<span class="pl-s"><span class="pl-pds">'</span>field<span class="pl-pds">'</span></span><span class="pl-k">:</span> {<span class="pl-s"><span class="pl-pds">'</span>value<span class="pl-pds">'</span></span><span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>pk<span class="pl-pds">'</span></span>]}}, <span class="pl-s"><span class="pl-pds">"</span>indexes<span class="pl-pds">"</span></span>).then(<span class="pl-k">function</span> () {
 <span class="pl-c">// Indexes have been overridden, no records though! override as well?</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack);
});</pre></div>

<p><strong>reindex([index])</strong>
<em>Haro</em></p>

<p>Re-indexes the DataStore, to be called if changing the value of <code>index</code>.</p>

<p>Example of mapping a DataStore:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

<span class="pl-c">// Data is added</span>

<span class="pl-c">// Creating a late index</span>
store.<span class="pl-c1">index</span>(<span class="pl-s"><span class="pl-pds">'</span>field3<span class="pl-pds">'</span></span>);

<span class="pl-c">// Recreating indexes, this should only happen if the store is out of sync caused by developer code.</span>
store.<span class="pl-c1">index</span>();</pre></div>

<p><strong>register(key, fn)</strong>
<em>Haro</em></p>

<p>Registers a persistent storage adapter.</p>

<p>Example of registering an adapter:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> haro <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>haro<span class="pl-pds">'</span></span>),
    store;

<span class="pl-c">// Configure a store to utilize the adapter</span>
store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {
  adapters<span class="pl-k">:</span> {
    mongo<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>mongo://localhost/mydb<span class="pl-pds">"</span></span>
  }
});

<span class="pl-c">// Register the adapter</span>
store.register(<span class="pl-s"><span class="pl-pds">'</span>mongo<span class="pl-pds">'</span></span>, <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>haro-mongo<span class="pl-pds">'</span></span>));</pre></div>

<p><strong>request(input, config)</strong>
<em>Promise</em></p>

<p>Returns a <code>Promise</code> for a <code>fetch()</code> with a triple <code>Tuple</code> [<code>body</code>, <code>status</code>, <code>headers</code>] as the <code>resolve()</code> &amp; <code>reject()</code> argument.</p>

<p>Example of mapping a DataStore:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro();

store.request(<span class="pl-s"><span class="pl-pds">'</span>https://somedomain.com/api<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(arg); <span class="pl-c">// [body, status, headers]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(arg[<span class="pl-c1">0</span>]);
});</pre></div>

<p><strong>save([adapter])</strong>
<em>Promise</em></p>

<p>Saves the DataStore to persistent storage.</p>

<p><strong>search(arg[, index=this.index])</strong>
<em>Tuple</em></p>

<p>Returns a <code>Tuple</code> of double <code>Tuples</code> with the shape <code>[key, value]</code> of records found matching <code>arg</code>.
If <code>arg</code> is a <code>Function</code> (parameters are <code>value</code> &amp; <code>index</code>) a match is made if the result is <code>true</code>, if <code>arg</code> is a <code>RegExp</code> the field value must <code>.test()</code> 
as <code>true</code>, else the value must be an identity match. The <code>index</code> parameter can be a <code>String</code> or <code>Array</code> of <code>Strings</code>; 
if not supplied it defaults to <code>this.index</code>.</p>

<p>Example of searching with a predicate function:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span>]}),
   data <span class="pl-k">=</span> [{name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">30</span>}, {name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">28</span>}];

store.batch(data, <span class="pl-s"><span class="pl-pds">'</span>set<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
 <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.<span class="pl-c1">search</span>(<span class="pl-k">function</span> (<span class="pl-smi">age</span>) {
   <span class="pl-k">return</span> age <span class="pl-k">&lt;</span> <span class="pl-c1">30</span>;
 }, <span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span>)); <span class="pl-c">// [[$uuid, {name: 'Jane Doe', age: 28}]]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<p><strong>set(key, data, batch=false, override=false)</strong>
<em>Promise</em></p>

<p>Returns a <code>Promise</code> for setting/amending a record in the DataStore, if <code>key</code> is <code>false</code> a version 4 <code>UUID</code> will be 
generated.</p>

<p>If <code>override</code> is <code>true</code>, the existing record will be replaced instead of amended.</p>

<p>Example of creating a record:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>});

store.set(<span class="pl-c1">null</span>, {id<span class="pl-k">:</span> <span class="pl-c1">1</span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span>}).then(<span class="pl-k">function</span> (<span class="pl-smi">record</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(record); <span class="pl-c">// [1, {id: 1, name: 'Jane Doe'}]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<p><strong>setUri(uri, clear=false)</strong>
<em>Promise</em></p>

<p>Returns a <code>Promise</code> for wiring the DataStore to an API, with the retrieved record set as the <code>resolve()</code> argument. This
creates an implicit mapping of <code>$uri/{key}</code> for records.</p>

<p>Pagination can be implemented by conditionally supplying <code>true</code> as the second argument. Doing so will <code>clear()</code> the 
DataStore prior to a batch insertion.</p>

<p>If <code>PATCH</code> requests are supported by the collection <code>batch()</code>, <code>del()</code> &amp; <code>set()</code> will make <code>JSONPatch</code> requests. If a 
<code>405</code> / <code>Method not Allowed</code> response occurs from a <code>PATCH</code> request, the DataStore will fallback to the appropriate 
method &amp; disable <code>PATCH</code> for subsequent requests.</p>

<p>Example setting the URI of the DataStore:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>});

store.setUri(<span class="pl-s"><span class="pl-pds">'</span>https://api.somedomain.com<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(records); <span class="pl-c">// [[$id, {...}], ...]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(arg[<span class="pl-c1">0</span>]); <span class="pl-c">// [body, statusCode]</span>
});</pre></div>

<p>Example of pagination, by specifying <code>clear</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>});

store.setUri(<span class="pl-s"><span class="pl-pds">'</span>https://api.somedomain.com?page=1<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(records); <span class="pl-c">// [[$id, {...}], ...]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(arg[<span class="pl-c1">0</span>]); <span class="pl-c">// [body, statusCode]</span>
});

<span class="pl-c">// Later, based on user interaction, change the page</span>
store.setUri(<span class="pl-s"><span class="pl-pds">'</span>https://api.somedomain.com?page=2<span class="pl-pds">'</span></span>, <span class="pl-c1">true</span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(records); <span class="pl-c">// [[$id, {...}], ...]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(arg[<span class="pl-c1">0</span>]); <span class="pl-c">// [body, statusCode]</span>
});</pre></div>

<p><strong>sort(callbackFn, [frozen = true])</strong>
<em>Array</em></p>

<p>Returns an Array of the DataStore, sorted by <code>callbackFn</code>.</p>

<p>Example of sorting like an <code>Array</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span>]}),
   data <span class="pl-k">=</span> [{name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">30</span>}, {name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">28</span>}];

store.batch(data, <span class="pl-s"><span class="pl-pds">'</span>set<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.<span class="pl-c1">sort</span>(<span class="pl-k">function</span> (<span class="pl-smi">a</span>, <span class="pl-smi">b</span>) {
    <span class="pl-k">return</span> a <span class="pl-k">&lt;</span> b <span class="pl-k">?</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">:</span> (a <span class="pl-k">&gt;</span> b <span class="pl-k">?</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">0</span>);
  })); <span class="pl-c">// [{name: 'Jane Doe', age: 28}, {name: 'John Doe', age: 30}]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<p><strong>sortBy(index)</strong>
<em>Tuple</em></p>

<p>Returns a <code>Tuple</code> of double <code>Tuples</code> with the shape <code>[key, value]</code> of records sorted by an index.</p>

<p>Example of sorting by an index:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span>]}),
   data <span class="pl-k">=</span> [{name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">30</span>}, {name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">28</span>}];

store.batch(data, <span class="pl-s"><span class="pl-pds">'</span>set<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.sortBy(<span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span>)); <span class="pl-c">// [[$uuid, {name: 'Jane Doe', age: 28}], [$uuid, {name: 'John Doe', age: 30}]]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<p><strong>sync(clear=false)</strong>
<em>Promise</em></p>

<p>Synchronises the DataStore with an API collection. If <code>clear</code> is <code>true</code>, the DataStore will have <code>clear()</code> executed
prior to <code>batch()</code> upon a successful retrieval of data.</p>

<p>Example of sorting by an index:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>}),
    interval;

store.setUri(<span class="pl-s"><span class="pl-pds">'</span>https://api.somedomain.com<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(records); <span class="pl-c">// [[$id, {...}], ...]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">arg</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(arg[<span class="pl-c1">0</span>]); <span class="pl-c">// [body, statusCode]</span>
});

<span class="pl-c">// Synchronizing the store every minute</span>
interval <span class="pl-k">=</span> <span class="pl-c1">setInterval</span>(<span class="pl-k">function</span> () {
  store.sync();
}, <span class="pl-c1">60000</span>);</pre></div>

<p><strong>toArray([data, freeze=true])</strong>
<em>Array</em></p>

<p>Returns an Array of the DataStore, or a subset.</p>

<p>Example of casting to an <code>Array</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(),
   data <span class="pl-k">=</span> [{name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">30</span>}, {name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">28</span>}];

store.batch(data, <span class="pl-s"><span class="pl-pds">'</span>set<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.toArray()); <span class="pl-c">// [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}]</span>
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.toArray(store.limit(<span class="pl-c1">1</span>))); <span class="pl-c">// [{name: 'John Doe', age: 30}]</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<p><strong>toObject([data, freeze=true])</strong>
<em>Object</em></p>

<p>Returns an Object of the DataStore.</p>

<p>Example of casting to an <code>Object</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>guid<span class="pl-pds">'</span></span>}),
   data <span class="pl-k">=</span> [{guid<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">30</span>}, {guid<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>def<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">28</span>}];

store.batch(data, <span class="pl-s"><span class="pl-pds">'</span>set<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.toObject()); <span class="pl-c">// {abc: {guid: 'abc', name: 'John Doe', age: 30}, def: {guid: 'def', name: 'Jane Doe', age: 28}}</span>
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.toObject(store.limit(<span class="pl-c1">1</span>)); <span class="pl-c">// {abc: {guid: 'abc', name: 'John Doe', age: 30}}}</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<p><strong>transform(input[, fn])</strong>
<em>Mixed</em></p>

<p>Transforms <code>Map</code> to <code>Object</code>, <code>Object</code> to <code>Map</code>, <code>Set</code> to <code>Array</code>, &amp; <code>Array</code> to <code>Set</code>. Accepts an optional second parameter to perform the
transformation to simplify cross domain issues.</p>

<p><code>haro.transform()</code> is exposed so that you can either duplicate it into the current context with <code>toString()</code> &amp; 
<code>new Function()</code>, or simply re-implement, for situations where you need to supply the transformation <code>Function</code>. </p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {key<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>guid<span class="pl-pds">'</span></span>, index<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>}),
   data <span class="pl-k">=</span> [{guid<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">30</span>}, {guid<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>def<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">28</span>}];

store.batch(data, <span class="pl-s"><span class="pl-pds">'</span>set<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(store.transform(store.indexes)); <span class="pl-c">// {age: {'28': ['def'], '30': ['abc']}, name: {'John Doe': ['abc'], 'Jane Doe': ['def']}}</span>
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<p><strong>unload([adapter=mongo, key])</strong>
<em>Promise</em></p>

<p>Unloads the DataStore, or a record from a specific persistent storage (delete).</p>

<p><strong>unregister(key)</strong>
<em>Haro</em></p>

<p>Un-registers a persistent storage adapter.</p>

<p>Example of unregistering an adapter:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> haro <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>haro<span class="pl-pds">'</span></span>),
    store;

<span class="pl-c">// Register the adapter</span>
haro.register(<span class="pl-s"><span class="pl-pds">'</span>mongo<span class="pl-pds">'</span></span>, <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>haro-mongo<span class="pl-pds">'</span></span>));

<span class="pl-c">// Configure a store to utilize the adapter</span>
store <span class="pl-k">=</span> haro(<span class="pl-c1">null</span>, {
  adapters<span class="pl-k">:</span> {
    mongo<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>mongo://localhost/mydb<span class="pl-pds">"</span></span>
  }
});

<span class="pl-c">// Later...</span>
store.unregister(<span class="pl-s"><span class="pl-pds">'</span>haro<span class="pl-pds">'</span></span>);</pre></div>

<p><strong>values()</strong>
<em>MapIterator</em></p>

<p>Returns a new <code>Iterator</code> object that contains the values for each element in the <code>Map</code> object in insertion order.</p>

<p>Example of iterating the values:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> store <span class="pl-k">=</span> haro(),
   data <span class="pl-k">=</span> [{name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>John Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">30</span>}, {name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane Doe<span class="pl-pds">'</span></span>, age<span class="pl-k">:</span> <span class="pl-c1">28</span>}];

store.batch(data, <span class="pl-s"><span class="pl-pds">'</span>set<span class="pl-pds">'</span></span>).then(<span class="pl-k">function</span> (<span class="pl-smi">records</span>) {
  <span class="pl-k">var</span> iterator <span class="pl-k">=</span> store.values(),
      item <span class="pl-k">=</span> iterator.<span class="pl-c1">next</span>();

  <span class="pl-k">do</span> {
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(item.<span class="pl-c1">value</span>);
    item <span class="pl-k">=</span> iterator.<span class="pl-c1">next</span>();
  } <span class="pl-k">while</span> (<span class="pl-k">!</span>item.done);
}, <span class="pl-k">function</span> (<span class="pl-smi">e</span>) {
  <span class="pl-en">console</span>.<span class="pl-c1">error</span>(e.stack <span class="pl-k">||</span> e.message <span class="pl-k">||</span> e);
});</pre></div>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>Copyright (c) 2015 Jason Mulligan
Licensed under the BSD-3 license</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/avoidwork/haro">Haro</a> is maintained by <a href="https://github.com/avoidwork">avoidwork</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

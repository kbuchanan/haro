{"name":"Haro","tagline":"Harō is modern DataStore that can be wired to an API","body":"# haro\r\n\r\n[![Join the chat at https://gitter.im/avoidwork/haro](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/avoidwork/haro?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n[![build status](https://secure.travis-ci.org/avoidwork/haro.svg)](http://travis-ci.org/avoidwork/haro)\r\n\r\nHarō is a modern immutable DataStore built with ES6 features, which can be wired to an API for a complete feedback loop.\r\nIt is un-opinionated, and offers a plug'n'play solution to modeling, searching, & managing data on the client, or server\r\n(in RAM). It is a [partially persistent data structure](https://en.wikipedia.org/wiki/Persistent_data_structure), by maintaining version sets of records in `versions` ([MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)).\r\n\r\nSynchronous commands return instantly (`Array` or `Tuple`), while asynchronous commands return  `Promises` which will\r\nresolve or reject in the future. This allows you to build complex applications without worrying about managing async \r\ncode.\r\n\r\nHarō indexes have the following structure `Map (field/property) > Map (value) > Set (PKs)` which allow for quick & easy \r\nsearching, as well as inspection. Indexes can be managed independently of `del()` & `set()` operations, for example you \r\ncan lazily create new indexes via `reindex(field)`, or `sortBy(field)`.\r\n\r\n### How to use\r\nHarō takes two optional arguments, the first is an `Array` of records to set asynchronously, & the second is a \r\nconfiguration descriptor.\r\n\r\n```javascript\r\nvar storeDefaults = haro();\r\nvar storeRecords = haro([{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}]);\r\nvar storeCustom = haro(null, {key: 'id'});\r\n```\r\n\r\n### Persistent Storage\r\nHarō is an in RAM only DataStore, so state could be lost if your program unexpectedly restarted, or some kind of \r\nmachine failure were to occur. To handle this serious problem, Harō affords a 1-n relationship with persistent storage \r\nadapters. You can register one or many adapters, and data updates will asynchronously persist to the various long term \r\nstorage systems.\r\n\r\nDataStore records will be stored separate of the DataStore snapshot itself (if you decide to leverage it), meaning you \r\nare responsible for doing a `load()` & `save()` at startup & shutdown. This is a manual process because it could be a \r\ntime bottleneck in the middle of using your application. Loading an individual record will update the DataStore with \r\nvalue from persistent storage.\r\n\r\nDataStore snapshots & individual records can be removed from persistent storage with `unload()`; it is not recommended \r\nto do this for an individual record, and to instead rely on `del()`, but it's afforded because it may be required.\r\n\r\n#### Creating an Adapter\r\nAdapters are simple in nature (can be isomorphic), and pretty easy to create! Follow the template below, fill in the \r\ngaps for your adapter as needed, such as handling multiple connection pools, etc.. The input parameters should not be \r\nmutated. The return must be a `Promise`.\r\n\r\n```javascript\r\n\"use strict\";\r\n\r\nconst Promise = require(\"es6-promise\").Promise;\r\n\r\nfunction deferred () {\r\n\tlet promise, resolver, rejecter;\r\n\r\n\tpromise = new Promise(function (resolve, reject) {\r\n\t\tresolver = resolve;\r\n\t\trejecter = reject;\r\n\t});\r\n\r\n\treturn {resolve: resolver, reject: rejecter, promise: promise};\r\n}\r\n\r\nfunction adapter (store, op, key, data) {\r\n\tlet defer = deferred(),\r\n\t\trecord = key !== undefined,\r\n\t\tconfig = store.adapters.myAdapterName,\r\n\t\tprefix = config.prefix || store.id,\r\n\t\tlkey = prefix + (record ? \"_\" + key : \"\")),\r\n\t\tclient = \"Your driver instance\";\r\n\r\n\tif (op === \"get\") {\r\n\t\tclient.get(lkey, function (e, reply) {\r\n\t\t\tlet result = JSON.parse(reply || null);\r\n\r\n\t\t\tif (e) {\r\n\t\t\t\tdefer.reject(e);\r\n\t\t\t} else if (result) {\r\n\t\t\t\tdefer.resolve(result);\r\n\t\t\t} else if (record) {\r\n\t\t\t\tdefer.reject(new Error(\"Record not found in myAdapterName\"));\r\n\t\t\t} else {\r\n\t\t\t\tdefer.reject([]);\r\n\t\t\t}\r\n\t\t});\r\n\t} else if (op === \"remove\") {\r\n\t\tclient.del(lkey, function (e) {\r\n\t\t\tif (e) {\r\n\t\t\t\tdefer.reject(e);\r\n\t\t\t} else {\r\n\t\t\t\tdefer.resolve(true);\r\n\t\t\t}\r\n\t\t});\r\n\t} else if (op === \"set\") {\r\n\t\tclient.set(lkey, JSON.stringify(record ? data : store.toArray()), function (e) {\r\n\t\t\tif (e) {\r\n\t\t\t\tdefer.reject(e);\r\n\t\t\t} else {\r\n\t\t\t\tdefer.resolve(true);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\treturn defer.promise;\r\n}\r\n\r\nmodule.exports = adapter;\r\n```\r\n\r\n### Examples\r\n#### Piping Promises\r\n```javascript\r\nvar store = haro();\r\n\r\nconsole.log(store.total); // 0\r\n\r\nstore.set(null, {abc: true}).then(function (arg) {\r\n  console.log(arg); // [$uuid, {abc: true}];\r\n  console.log(store.total); // 1\r\n  return store.set(arg[0], {abc: false});\r\n}).then(function (arg) {\r\n  console.log(arg); // [$uuid, {abc: false}];\r\n  console.log(store.versions.get(arg[0]).size); // 1;\r\n  return store.del(arg[0])\r\n}).then(function () {\r\n  console.log(store.total); // 0;\r\n}).catch(function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n#### Indexes & Searching\r\n```javascript\r\nvar store = haro(null, {index: ['name', 'age']}),\r\n    data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  console.log(records[0]); // [$uuid, {name: 'John Doe', age: 30}]\r\n  console.log(store.total); // 2\r\n  console.log(store.find({age: 28})); // [[$uuid, {name: 'Jane Doe', age: 28}]]\r\n  console.log(store.search(/^ja/i, 'name')); // [[$uuid, {name: 'Jane Doe', age: 28}]]\r\n  console.log(store.search(function (age) { return age < 30; }, 'age')); // [[$uuid, {name: 'Jane Doe', age: 28}]]\r\n}).catch(function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n#### MVCC versioning\r\n```javascript\r\nvar store = haro();\r\n\r\nstore.set(null, {abc: true}).then(function (arg) {\r\n  return store.set(arg[0], {abc: false});\r\n}).then(function (arg) {\r\n  return store.set(arg[0], {abc: true});\r\n}).then(function (arg) {\r\n  store.versions.get(arg[0]).forEach(function (i) { console.log(i[0]); }); // {abc: true}, {abc: false}\r\n}).catch(function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n### Benchmarked\r\nA benchmark is included in the repository, and is useful for gauging how haro will perform on different hardware, & software.\r\nPlease consider that `batch()`, & `set()` use `Promises` and incur time as a cost. The following results are from an Apple\r\nMacBook Air (Early 2014) / 8GB RAM / 512GB SSD / OS X Yosemite:\r\n\r\n```\r\ntime to load data: 595.13794ms\r\ndatastore record count: 15000\r\nname indexes: 15000\r\ntesting time to 'find()' a record (first one is cold):\r\n0.333202ms\r\n0.15953ms\r\n0.091702ms\r\n0.091607ms\r\n0.077321ms\r\ntesting time to 'search(regex, index)' for a record (first one is cold):\r\n2.22693ms\r\n1.339148ms\r\n1.59494ms\r\n1.28051ms\r\n1.191318ms\r\n```\r\n\r\n### Configuration\r\n**adapters**\r\n_Object_\r\n\r\nObject of {(storage): (connection string)} pairs. Collection/table name is the value of `this.id`.\r\n\r\nAvailable adapters: _mongo_\r\n\r\nExample of specifying MongoDB as persistent storage:\r\n```javascript\r\nvar store = haro(null, {\r\n  adapters: {\r\n    mongo: \"mongo://localhost/mine\"\r\n  }\r\n});\r\n```\r\n\r\n**config**\r\n_Object_\r\n\r\nDefault settings for `fetch()`.\r\n\r\nExample of specifying a bearer token authorization header:\r\n```javascript\r\nvar store = haro(null, {\r\n  config: {\r\n    headers: {\r\n      authorization: 'Bearer abcdef'\r\n    }\r\n  });\r\n```\r\n\r\n**index**\r\n_Array_\r\n\r\nArray of values to index. Composite indexes are supported, by using the default delimiter (`this.delimiter`).\r\nNon-matches within composites result in blank values.\r\n\r\nExample of fields/properties to index:\r\n```javascript\r\nvar store = haro(null, {index: ['field1', 'field2', 'field1|field2|field3']);\r\n```\r\n\r\n**key**\r\n_String_\r\n\r\nOptional `Object` key to utilize as `Map` key, defaults to a version 4 `UUID` if not specified, or found.\r\n\r\nExample of specifying the primary key:\r\n```javascript\r\nvar store = haro(null, {key: 'field'});\r\n```\r\n\r\n**logging**\r\n_Boolean_\r\n\r\nLogs persistent storage messages to `console`, default is `true`.\r\n\r\n**source**\r\n_String_\r\n\r\nOptional `Object` key to retrieve data from API responses, see `setUri()`.\r\n\r\nExample of specifying the source of data:\r\n```javascript\r\nvar store = haro(null, {source: 'data'});\r\n```\r\n\r\n**versioning**\r\n_Boolean_\r\n\r\nEnable/disable MVCC style versioning of records, default is `true`. Versions are stored in `Sets` for easy iteration.\r\n\r\nExample of disabling versioning:\r\n```javascript\r\nvar store = haro(null, {versioning: false});\r\n```\r\n\r\n### Properties\r\n**data**\r\n_Map_\r\n\r\n`Map` of records, updated by `del()` & `set()`.\r\n\r\n**indexes**\r\n_Map_\r\n\r\nMap of indexes, which are Sets containing Map keys.\r\n\r\n**patch**\r\n_Boolean_\r\n\r\nSet from the success handler of `sync()`, infers `PATCH` requests are supported by the API collection.\r\n\r\n**registry**\r\n_Array_\r\n\r\nArray representing the order of `this.data`.\r\n\r\n**total**\r\n_Number_\r\n\r\nTotal records in the DataStore.\r\n\r\n**uri**\r\n_String_\r\n\r\nAPI collection URI the DataStore is wired to, in a feedback loop (do not modify, use `setUri()`). Setting the value creates an implicit relationship with records, e.g. setting `/users` would imply a URI structure of `/users/{key}`. Trailing slashes may be stripped.\r\n\r\n**versions**\r\n_Map_\r\n\r\n`Map` of `Sets` of records, updated by `set()`.\r\n\r\n### API\r\n**batch( array, type )**\r\n_Promise_\r\n\r\nThe first argument must be an `Array`, and the second argument must be `del` or `set`. Batch operations with a DataStore \r\nthat is wired to an API with pagination enabled & `PATCH` support may create erroneous operations, such as `add` where\r\n`replace` is appropriate; this will happen because the DataStore will not have the entire data set to generate it's \r\n[JSONPatch](http://jsonpatchjs.com/) request.\r\n\r\n```javascript\r\nvar haro = require('haro'),\r\n    store = haro(null, {key: 'id', index: ['name']}),\r\n    i = -1,\r\n    nth = 100,\r\n    data = [];\r\n\r\nwhile (++i < nth) {\r\n  data.push({id: i, name: 'John Doe' + i});\r\n}\r\n\r\nstore.batch(data, 'set').then(function(records) {\r\n  // records is a Tuple of Tuples\r\n}, function (e) {\r\n  console.error(e.stack);\r\n});\r\n```\r\n\r\n**clear()**\r\n_self_\r\n\r\nRemoves all key/value pairs from the DataStore.\r\n\r\nExample of clearing a DataStore:\r\n```javascript\r\nvar store = haro();\r\n\r\n// Data is added\r\n\r\nstore.clear();\r\n```\r\n\r\n**del( key )**\r\n_Promise_\r\n\r\nDeletes the record.\r\n\r\nExample of deleting a record:\r\n```javascript\r\nvar store = haro();\r\n\r\nstore.set(null, {abc: true}).then(function (rec) {\r\n  return store.del(rec[0]);\r\n}, function (e) {\r\n  throw e;\r\n}).then(function () {\r\n  console.log(store.total); // 0\r\n}, function (e) {\r\n  console.error(e.stack);\r\n});\r\n```\r\n\r\n**entries()**\r\n_MapIterator_\r\n\r\nReturns returns a new `Iterator` object that contains an array of `[key, value]` for each element in the `Map` object in \r\ninsertion order.\r\n\r\nExample of deleting a record:\r\n```javascript\r\nvar store = haro(),\r\n    item, iterator;\r\n\r\n// Data is added\r\n\r\niterator = store.entries();\r\nitem = iterator.next();\r\n\r\ndo {\r\n  console.log(item.value);\r\n  item = iterator.next();\r\n} while (!item.done);\r\n```\r\n\r\n**filter( callbackFn )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of double `Tuples` with the shape `[key, value]` for records which returned `true` to \r\n`callbackFn(value, key)`.\r\n\r\nExample of filtering a DataStore:\r\n```javascript\r\nvar store = haro();\r\n\r\n// Data is added\r\n\r\nstore.filter(function (value) {\r\n  return value.something === true;\r\n});\r\n```\r\n\r\n**find( where )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of double `Tuples` with found by indexed values matching the `where`.\r\n\r\nExample of finding a record(s) with an identity match:\r\n```javascript\r\nvar store = haro(null, {index: ['field1']});\r\n\r\n// Data is added\r\n\r\nstore.find({field1: 'some value'});\r\n```\r\n\r\n**forEach( callbackFn[, thisArg] )**\r\n_Undefined_\r\n\r\nCalls `callbackFn` once for each key-value pair present in the `Map` object, in insertion order. If a `thisArg` \r\nparameter is provided to `forEach`, it will be used as the this value for each callback.\r\n\r\nExample of deleting a record:\r\n```javascript\r\nvar store = haro();\r\n\r\nstore.set(null, {abc: true}).then(function (rec) {\r\n  store.forEach(function (value, key) {\r\n    console.log(key);\r\n  });\r\n}, function (e) {\r\n  console.error(e.stack);\r\n});\r\n```\r\n\r\n**get( key )**\r\n_Tuple_\r\n\r\nGets the record as a double `Tuple` with the shape `[key, value]`.\r\n\r\nExample of getting a record with a known primary key value:\r\n```javascript\r\nvar store = haro();\r\n\r\n// Data is added\r\n\r\nstore.get('keyValue');\r\n```\r\n\r\n**keys()**\r\n_MapIterator_\r\n\r\nReturns a new `Iterator` object that contains the keys for each element in the `Map` object in insertion order.`\r\n\r\nExample of getting an iterator, and logging the results:\r\n```javascript\r\nvar store = haro(),\r\n    item, iterator;\r\n\r\n// Data is added\r\n\r\niterator = store.keys();\r\nitem = iterator.next();\r\n\r\ndo {\r\n  console.log(item.value);\r\n  item = iterator.next();\r\n} while (!item.done);\r\n```\r\n\r\n**limit( max, offset=0 )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of double `Tuples` with the shape `[key, value]` for the corresponding range of records.\r\n\r\nExample of paginating a data set:\r\n```javascript\r\nvar store = haro(), ds1, ds2;\r\n\r\n// Data is added\r\n\r\nconsole.log(store.total); // >10\r\nds1 = store.limit(10);     // [0-9]\r\nds2 = store.limit(10, 10); // [10-19]\r\n\r\nconsole.log(ds1.length === ds2.length); // true\r\nconsole.log(JSON.stringify(ds1[0][1]) === JSON.stringify(ds2[0][1])); // false\r\n```\r\n\r\n**load( [adapter=mongo, key] )**\r\n_Promise_\r\n\r\nLoads the DataStore, or a record from a specific persistent storage & updates the DataStore. The DataStore will be cleared \r\nprior to loading if `key` is omitted.\r\n\r\n**map( callbackFn )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of the returns of `callbackFn(value, key)`.\r\n\r\nExample of mapping a DataStore:\r\n```javascript\r\nvar store = haro();\r\n\r\n// Data is added\r\n\r\nstore.map(function (value) {\r\n  return value.property;\r\n});\r\n```\r\n\r\n**reindex( [index] )**\r\n_Haro_\r\n\r\nRe-indexes the DataStore, to be called if changing the value of `index`.\r\n\r\nExample of mapping a DataStore:\r\n```javascript\r\nvar store = haro();\r\n\r\n// Data is added\r\n\r\n// Creating a late index\r\nstore.index('field3');\r\n\r\n// Recreating indexes, this should only happen if the store is out of sync caused by developer code.\r\nstore.index();\r\n```\r\n\r\n**register( key, fn )**\r\n_Haro_\r\n\r\nRegisters a persistent storage adapter.\r\n\r\nExample of registering an adapter:\r\n```javascript\r\nvar haro = require('haro'),\r\n    store;\r\n\r\n// Configure a store to utilize the adapter\r\nstore = haro(null, {\r\n  adapters: {\r\n    mongo: \"mongo://localhost/mydb\"\r\n  }\r\n});\r\n\r\n// Register the adapter\r\nstore.register('mongo', require('haro-mongo'));\r\n```\r\n\r\n**request( input, config )**\r\n_Promise_\r\n\r\nReturns a `Promise` for a `fetch()` with a triple `Tuple` [`body`, `status`, `headers`] as the `resolve()` & `reject()` argument.\r\n\r\nExample of mapping a DataStore:\r\n```javascript\r\nvar store = haro();\r\n\r\nstore.request('https://somedomain.com/api').then(function (arg) {\r\n  console.log(arg); // [body, status, headers]\r\n}, function (arg) {\r\n  console.error(arg[0]);\r\n});\r\n```\r\n\r\n**save( [adapter] )**\r\n_Promise_\r\n\r\nSaves the DataStore to persistent storage.\r\n\r\n**search( arg[, index=this.index] )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of double `Tuples` with the shape `[key, value]` of records found matching `arg`.\r\nIf `arg` is a `Function` (parameters are `value` & `index`) a match is made if the result is `true`, if `arg` is a `RegExp` the field value must `.test()` \r\nas `true`, else the value must be an identity match. The `index` parameter can be a `String` or `Array` of `Strings`; \r\nif not supplied it defaults to `this.index`.\r\n\r\nExample of searching with a predicate function:\r\n```javascript\r\nvar store = haro(null, {index: ['name', 'age']}),\r\n   data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n console.log(store.search(function (age) {\r\n   return age < 30;\r\n }, 'age')); // [[$uuid, {name: 'Jane Doe', age: 28}]]\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**set( key, data, batch=false, override=false )**\r\n_Promise_\r\n\r\nReturns a `Promise` for setting/amending a record in the DataStore, if `key` is `false` a version 4 `UUID` will be \r\ngenerated.\r\n\r\nIf `override` is `true`, the existing record will be replaced instead of amended.\r\n\r\nExample of creating a record:\r\n```javascript\r\nvar store = haro(null, {key: 'id'});\r\n\r\nstore.set(null, {id: 1, name: 'John Doe'}).then(function (record) {\r\n  console.log(record); // [1, {id: 1, name: 'Jane Doe'}]\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**setUri( uri, clear=false )**\r\n_Promise_\r\n\r\nReturns a `Promise` for wiring the DataStore to an API, with the retrieved record set as the `resolve()` argument. This\r\ncreates an implicit mapping of `$uri/{key}` for records.\r\n\r\nPagination can be implemented by conditionally supplying `true` as the second argument. Doing so will `clear()` the \r\nDataStore prior to a batch insertion.\r\n\r\nIf `PATCH` requests are supported by the collection `batch()`, `del()` & `set()` will make `JSONPatch` requests. If a \r\n`405` / `Method not Allowed` response occurs from a `PATCH` request, the DataStore will fallback to the appropriate \r\nmethod & disable `PATCH` for subsequent requests.\r\n\r\nExample setting the URI of the DataStore:\r\n```javascript\r\nvar store = haro(null, {key: 'id'});\r\n\r\nstore.setUri('https://api.somedomain.com').then(function (records) {\r\n  console.log(records); // [[$id, {...}], ...]\r\n}, function (arg) {\r\n  console.error(arg[0]); // [body, statusCode]\r\n});\r\n```\r\n\r\nExample of pagination, by specifying `clear`:\r\n```javascript\r\nvar store = haro(null, {key: 'id'});\r\n\r\nstore.setUri('https://api.somedomain.com?page=1').then(function (records) {\r\n  console.log(records); // [[$id, {...}], ...]\r\n}, function (arg) {\r\n  console.log(arg[0]); // [body, statusCode]\r\n});\r\n\r\n// Later, based on user interaction, change the page\r\nstore.setUri('https://api.somedomain.com?page=2', true).then(function (records) {\r\n  console.log(records); // [[$id, {...}], ...]\r\n}, function (arg) {\r\n  console.error(arg[0]); // [body, statusCode]\r\n});\r\n```\r\n\r\n**sort( callbackFn )**\r\n_Array_\r\n\r\nReturns an Array of the DataStore, sorted by `callbackFn`.\r\n\r\nExample of sorting like an `Array`:\r\n```javascript\r\nvar store = haro(null, {index: ['name', 'age']}),\r\n   data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  console.log(store.sort(function (a, b) {\r\n    return a < b ? -1 : (a > b ? 1 : 0);\r\n  })); // [{name: 'Jane Doe', age: 28}, {name: 'John Doe', age: 30}]\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**sortBy( index )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of double `Tuples` with the shape `[key, value]` of records sorted by an index.\r\n\r\nExample of sorting by an index:\r\n```javascript\r\nvar store = haro(null, {index: ['name', 'age']}),\r\n   data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  console.log(store.sortBy('age')); // [[$uuid, {name: 'Jane Doe', age: 28}], [$uuid, {name: 'John Doe', age: 30}]]\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**sync( clear=false )**\r\n_Promise_\r\n\r\nSynchronises the DataStore with an API collection. If `clear` is `true`, the DataStore will have `clear()` executed\r\nprior to `batch()` upon a successful retrieval of data.\r\n\r\nExample of sorting by an index:\r\n```javascript\r\nvar store = haro(null, {key: 'id'}),\r\n    interval;\r\n\r\nstore.setUri('https://api.somedomain.com').then(function (records) {\r\n  console.log(records); // [[$id, {...}], ...]\r\n}, function (arg) {\r\n  console.error(arg[0]); // [body, statusCode]\r\n});\r\n\r\n// Synchronizing the store every minute\r\ninterval = setInterval(function () {\r\n  store.sync();\r\n}, 60000);\r\n```\r\n\r\n**toArray( [data, freeze=true] )**\r\n_Array_\r\n\r\nReturns an Array of the DataStore, or a subset.\r\n\r\nExample of casting to an `Array`:\r\n```javascript\r\nvar store = haro(),\r\n   data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  console.log(store.toArray()); // [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}]\r\n  console.log(store.toArray(store.limit(1))); // [{name: 'John Doe', age: 30}]\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**toObject( [data, freeze=true] )**\r\n_Object_\r\n\r\nReturns an Object of the DataStore.\r\n\r\nExample of casting to an `Object`:\r\n```javascript\r\nvar store = haro(null, {key: 'guid'}),\r\n   data = [{guid: 'abc', name: 'John Doe', age: 30}, {guid: 'def', name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  console.log(store.toObject()); // {abc: {guid: 'abc', name: 'John Doe', age: 30}, def: {guid: 'def', name: 'Jane Doe', age: 28}}\r\n  console.log(store.toObject(store.limit(1)); // {abc: {guid: 'abc', name: 'John Doe', age: 30}}}\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**unload( [adapter=mongo, key] )**\r\n_Promise_\r\n\r\nUnloads the DataStore, or a record from a specific persistent storage (delete).\r\n\r\n**unregister( key )**\r\n_Haro_\r\n\r\nUn-registers a persistent storage adapter.\r\n\r\nExample of unregistering an adapter:\r\n```javascript\r\nvar haro = require('haro'),\r\n    store;\r\n\r\n// Register the adapter\r\nharo.register('mongo', require('haro-mongo'));\r\n\r\n// Configure a store to utilize the adapter\r\nstore = haro(null, {\r\n  adapters: {\r\n    mongo: \"mongo://localhost/mydb\"\r\n  }\r\n});\r\n\r\n// Later...\r\nstore.unregister('haro');\r\n```\r\n\r\n**values()**\r\n_MapIterator_\r\n\r\nReturns a new `Iterator` object that contains the values for each element in the `Map` object in insertion order.\r\n\r\nExample of iterating the values:\r\n```javascript\r\nvar store = haro(),\r\n   data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  var iterator = store.values(),\r\n      item = iterator.next();\r\n\r\n  do {\r\n    console.log(item.value);\r\n    item = iterator.next();\r\n  } while (!item.done);\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n### Requirements\r\n- `Map`\r\n- `Promise`\r\n- `Set`\r\n- `fetch()`\r\n- `tuple()` see [tiny-tuple](https://github.com/avoidwork/tiny-tuple) for loading in a browser\r\n\r\n## License\r\nCopyright (c) 2015 Jason Mulligan\r\nLicensed under the BSD-3 license\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
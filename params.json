{"name":"Haro","tagline":"Harō is modern DataStore that can be wired to an API","body":"# haro\r\n\r\n[![build status](https://secure.travis-ci.org/avoidwork/haro.svg)](http://travis-ci.org/avoidwork/haro)\r\n\r\nHarō is a modern immutable DataStore built with ES6 features, which can be wired to an API for a complete feedback loop.\r\nIt is un-opinionated, and offers a plug'n'play solution to modeling, searching, & managing data on the client, or server\r\n(in RAM). It is a [partially persistent data structure](https://en.wikipedia.org/wiki/Persistent_data_structure), by maintaining version sets of records in `versions` ([MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)).\r\n\r\nSynchronous commands return instantly (`Array` or `Tuple`), while asynchronous commands return  `Promises` which will\r\nresolve or reject in the future. This allows you to build complex applications without worrying about managing async code.\r\n\r\nHarō indexes have the following structure `Map (field/property) > Map (value) > Set (PKs)` which allow for quick & easy searching, as well as inspection.\r\nIndexes can be managed independently of `del()` & `set()` operations, for example you can lazily create new indexes via `reindex(field)`, or `sortBy(field)`.\r\n\r\n### How to use\r\nHarō takes two optional arguments, the first is an `Array` of records to set asynchronously, & the second is a configuration descriptor.\r\n\r\n```javascript\r\nvar storeDefaults = haro();\r\nvar storeRecords = haro([{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}]);\r\nvar storeCustom = haro(null, {key: 'id'});\r\n```\r\n\r\n### Examples\r\n#### Piping Promises\r\n```javascript\r\nvar store = haro();\r\n\r\nconsole.log(store.total); // 0\r\n\r\nstore.set(null, {abc: true}).then(function (arg) {\r\n  console.log(arg); // [$uuid, {abc: true}];\r\n  console.log(store.total); // 1\r\n  return store.set(arg[0], {abc: false});\r\n}).then(function (arg) {\r\n  console.log(arg); // [$uuid, {abc: false}];\r\n  console.log(store.versions.get(arg[0]).size); // 1;\r\n  return store.del(arg[0])\r\n}).then(function () {\r\n  console.log(store.total); // 0;\r\n}).catch(function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n#### Indexes & Searching\r\n```javascript\r\nvar store = haro(null, {index: ['name', 'age']}),\r\n    data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  console.log(records[0]); // [$uuid, {name: 'John Doe', age: 30}]\r\n  console.log(store.total); // 2\r\n  console.log(store.find({age: 28})); // [[$uuid, {name: 'Jane Doe', age: 28}]]\r\n  console.log(store.search(/^ja/i, 'name')); // [[$uuid, {name: 'Jane Doe', age: 28}]]\r\n  console.log(store.search(function (age) { return age < 30; }, 'age')); // [[$uuid, {name: 'Jane Doe', age: 28}]]\r\n}).catch(function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n#### MVCC versioning\r\n```javascript\r\nvar store = haro();\r\n\r\nstore.set(null, {abc: true}).then(function (arg) {\r\n  return store.set(arg[0], {abc: false});\r\n}).then(function (arg) {\r\n  return store.set(arg[0], {abc: true});\r\n}).then(function (arg) {\r\n  store.versions.get(arg[0]).forEach(function (i) { console.log(i[0]); }); // {abc: true}, {abc: false}\r\n}).catch(function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n### Benchmarked\r\nA benchmark is included in the repository, and is useful for gauging how haro will perform on different hardware, & software.\r\nPlease consider that `batch()`, & `set()` use `Promises` and incur time as a cost. The following results are from an Apple\r\nMacBook Air (Early 2014) / 8GB RAM / 512GB SSD / OS X Yosemite:\r\n\r\n```\r\ntime to load data: 595.13794ms\r\ndatastore record count: 15000\r\nname indexes: 15000\r\ntesting time to 'find()' a record (first one is cold):\r\n0.333202ms\r\n0.15953ms\r\n0.091702ms\r\n0.091607ms\r\n0.077321ms\r\ntesting time to 'search(regex, index)' for a record (first one is cold):\r\n2.22693ms\r\n1.339148ms\r\n1.59494ms\r\n1.28051ms\r\n1.191318ms\r\n```\r\n\r\n### Configuration\r\n**config**\r\n_Object_\r\n\r\nDefault settings for `fetch()`.\r\n\r\nExample of specifying a bearer token authorization header:\r\n```javascript\r\nvar store = haro(null, {\r\n  config: {\r\n    headers: {\r\n      authorization: 'Bearer abcdef'\r\n    }\r\n  });\r\n```\r\n\r\n**index**\r\n_Array_\r\n\r\nArray of values to index. Composite indexes are supported, by using the default delimiter (`this.delimiter`).\r\nNon-matches within composites result in blank values.\r\n\r\nExample of fields/properties to index:\r\n```javascript\r\nvar store = haro(null, {index: ['field1', 'field2', 'field1|field2|field3']);\r\n```\r\n\r\n**key**\r\n_String_\r\n\r\nOptional `Object` key to utilize as `Map` key, defaults to a version 4 `UUID` if not specified, or found.\r\n\r\nExample of specifying the primary key:\r\n```javascript\r\nvar store = haro(null, {key: 'field'});\r\n```\r\n\r\n**source**\r\n_String_\r\n\r\nOptional `Object` key to retrieve data from API responses, see `setUri()`.\r\n\r\nExample of specifying the source of data:\r\n```javascript\r\nvar store = haro(null, {source: 'data'});\r\n```\r\n\r\n**versioning**\r\n_Boolean_\r\n\r\nEnable/disable MVCC style versioning of records, default is `true`. Versions are stored in `Sets` for easy iteration.\r\n\r\nExample of disabling versioning:\r\n```javascript\r\nvar store = haro(null, {versioning: false});\r\n```\r\n\r\n### Properties\r\n**data**\r\n_Map_\r\n\r\n`Map` of records, updated by `del()` & `set()`.\r\n\r\n**indexes**\r\n_Map_\r\n\r\nMap of indexes, which are Sets containing Map keys.\r\n\r\n**patch**\r\n_Boolean_\r\n\r\nSet from the success handler of `sync()`, infers `PATCH` requests are supported by the API collection.\r\n\r\n**registry**\r\n_Array_\r\n\r\nArray representing the order of `this.data`.\r\n\r\n**total**\r\n_Number_\r\n\r\nTotal records in the DataStore.\r\n\r\n**uri**\r\n_String_\r\n\r\nAPI collection URI the DataStore is wired to, in a feedback loop (do not modify, use `setUri()`). Setting the value creates an implicit relationship with records, e.g. setting `/users` would imply a URI structure of `/users/{key}`. Trailing slashes may be stripped.\r\n\r\n**versions**\r\n_Map_\r\n\r\n`Map` of `Sets` of records, updated by `set()`.\r\n\r\n### API\r\n**batch( array, type )**\r\n_Promise_\r\n\r\nThe first argument must be an `Array`, and the second argument must be `del` or `set`. Batch operations with a DataStore \r\nthat is wired to an API with pagination enabled & `PATCH` support may create erroneous operations, such as `add` where\r\n`replace` is appropriate; this will happen because the DataStore will not have the entire data set to generate it's \r\n[JSONPatch](http://jsonpatchjs.com/) request.\r\n\r\n```javascript\r\nvar haro = require('haro'),\r\n    store = haro(null, {key: 'id', index: ['name']}),\r\n    i = -1,\r\n    nth = 100,\r\n    data = [];\r\n\r\nwhile (++i < nth) {\r\n  data.push({id: i, name: 'John Doe' + i});\r\n}\r\n\r\nstore.batch(data, 'set').then(function(records) {\r\n  // records is a Tuple of Tuples\r\n}, function (e) {\r\n  console.error(e.stack);\r\n});\r\n```\r\n\r\n**clear()**\r\n_self_\r\n\r\nRemoves all key/value pairs from the DataStore.\r\n\r\nExample of clearing a DataStore:\r\n```javascript\r\nvar store = haro();\r\n\r\n// Data is added\r\n\r\nstore.clear();\r\n```\r\n\r\n**del( key )**\r\n_Promise_\r\n\r\nDeletes the record.\r\n\r\nExample of deleting a record:\r\n```javascript\r\nvar store = haro();\r\n\r\nstore.set(null, {abc: true}).then(function (rec) {\r\n  return store.del(rec[0]);\r\n}, function (e) {\r\n  throw e;\r\n}).then(function () {\r\n  console.log(store.total); // 0\r\n}, function (e) {\r\n  console.error(e.stack);\r\n});\r\n```\r\n\r\n**entries()**\r\n_MapIterator_\r\n\r\nReturns returns a new `Iterator` object that contains an array of `[key, value]` for each element in the `Map` object in \r\ninsertion order.\r\n\r\nExample of deleting a record:\r\n```javascript\r\nvar store = haro(),\r\n    item, iterator;\r\n\r\n// Data is added\r\n\r\niterator = store.entries();\r\nitem = iterator.next();\r\n\r\ndo {\r\n  console.log(item.value);\r\n  item = iterator.next();\r\n} while (!item.done);\r\n```\r\n\r\n**filter( callbackFn )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of double `Tuples` with the shape `[key, value]` for records which returned `true` to \r\n`callbackFn(value, key)`.\r\n\r\nExample of filtering a DataStore:\r\n```javascript\r\nvar store = haro();\r\n\r\n// Data is added\r\n\r\nstore.filter(function (value) {\r\n  return value.something === true;\r\n});\r\n```\r\n\r\n**find( where )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of double `Tuples` with found by indexed values matching the `where`.\r\n\r\nExample of finding a record(s) with an identity match:\r\n```javascript\r\nvar store = haro(null, {index: ['field1']});\r\n\r\n// Data is added\r\n\r\nstore.find({field1: 'some value'});\r\n```\r\n\r\n**forEach( callbackFn[, thisArg] )**\r\n_Undefined_\r\n\r\nCalls `callbackFn` once for each key-value pair present in the `Map` object, in insertion order. If a `thisArg` \r\nparameter is provided to `forEach`, it will be used as the this value for each callback.\r\n\r\nExample of deleting a record:\r\n```javascript\r\nvar store = haro();\r\n\r\nstore.set(null, {abc: true}).then(function (rec) {\r\n  store.forEach(function (value, key) {\r\n    console.log(key);\r\n  });\r\n}, function (e) {\r\n  console.error(e.stack);\r\n});\r\n```\r\n\r\n**get( key )**\r\n_Tuple_\r\n\r\nGets the record as a double `Tuple` with the shape `[key, value]`.\r\n\r\nExample of getting a record with a known primary key value:\r\n```javascript\r\nvar store = haro();\r\n\r\n// Data is added\r\n\r\nstore.get('keyValue');\r\n```\r\n\r\n**keys()**\r\n_MapIterator_\r\n\r\nReturns a new `Iterator` object that contains the keys for each element in the `Map` object in insertion order.`\r\n\r\nExample of getting an iterator, and logging the results:\r\n```javascript\r\nvar store = haro(),\r\n    item, iterator;\r\n\r\n// Data is added\r\n\r\niterator = store.keys();\r\nitem = iterator.next();\r\n\r\ndo {\r\n  console.log(item.value);\r\n  item = iterator.next();\r\n} while (!item.done);\r\n```\r\n\r\n**limit( offset=0, max )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of double `Tuples` with the shape `[key, value]` for the corresponding range of records.\r\n\r\nExample of paginating a data set:\r\n```javascript\r\nvar store = haro(), ds1, ds2;\r\n\r\n// Data is added\r\n\r\nconsole.log(store.total); // >10\r\nds1 = store.limit(10);     // [0-9]\r\nds2 = store.limit(10, 10); // [10-19]\r\n\r\nconsole.log(ds1.length === ds2.length); // true\r\nconsole.log(JSON.stringify(ds1[0][1]) === JSON.stringify(ds2[0][1])); // false\r\n```\r\n\r\n**map( callbackFn )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of the returns of `callbackFn(value, key)`.\r\n\r\nExample of mapping a DataStore:\r\n```javascript\r\nvar store = haro();\r\n\r\n// Data is added\r\n\r\nstore.map(function (value) {\r\n  return value.property;\r\n});\r\n```\r\n\r\n**reindex( [index] )**\r\n_Haro_\r\n\r\nRe-indexes the DataStore, to be called if changing the value of `index`.\r\n\r\nExample of mapping a DataStore:\r\n```javascript\r\nvar store = haro();\r\n\r\n// Data is added\r\n\r\n// Creating a late index\r\nstore.index('field3');\r\n\r\n// Recreating indexes, this should only happen if the store is out of sync caused by developer code.\r\nstore.index();\r\n```\r\n\r\n\r\n**request( input, config )**\r\n_Promise_\r\n\r\nReturns a `Promise` for a `fetch()` with a double `Tuple` [`body`, `status`] as the `resolve()` argument.\r\n\r\nExample of mapping a DataStore:\r\n```javascript\r\nvar store = haro();\r\n\r\nstore.request('https://somedomain.com/api').then(function (arg) {\r\n  console.log(arg); // [body, status]\r\n}, function (arg) {\r\n  console.error(arg[0]);\r\n});\r\n```\r\n\r\n**search( arg, index )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of double `Tuples` with the shape `[key, value]` of records found matching `arg`.\r\nIf `arg` is a `Function` a match is made if the result is `true`, if `arg` is a `RegExp` the field value must `.test()` \r\nas `true`, else the value must be an equality match.\r\n\r\nExample of searching with a predicate function:\r\n```javascript\r\nvar store = haro(null, {index: ['name', 'age']}),\r\n   data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n console.log(store.search(function (age) {\r\n   return age < 30;\r\n }, 'age')); // [[$uuid, {name: 'Jane Doe', age: 28}]]\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**set( key, data, batch=false, override=false )**\r\n_Promise_\r\n\r\nReturns a `Promise` for setting/amending a record in the DataStore, if `key` is `false` a version 4 `UUID` will be \r\ngenerated.\r\n\r\nIf `override` is `true`, the existing record will be replaced instead of amended.\r\n\r\nExample of creating a record:\r\n```javascript\r\nvar store = haro(null, {key: 'id'});\r\n\r\nstore.set(null, {id: 1, name: 'John Doe'}).then(function (record) {\r\n  console.log(record); // [1, {id: 1, name: 'Jane Doe'}]\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**setUri( uri, clear=false )**\r\n_Promise_\r\n\r\nReturns a `Promise` for wiring the DataStore to an API, with the retrieved record set as the `resolve()` argument. This\r\ncreates an implicit mapping of `$uri/{key}` for records.\r\n\r\nPagination can be implemented by conditionally supplying `true` as the second argument. Doing so will `clear()` the \r\nDataStore prior to a batch insertion.\r\n\r\nIf `PATCH` requests are supported by the collection `batch()`, `del()` & `set()` will make `JSONPatch` requests. If a \r\n`405` / `Method not Allowed` response occurs from a `PATCH` request, the DataStore will fallback to the appropriate \r\nmethod & disable `PATCH` for subsequent requests.\r\n\r\nExample setting the URI of the DataStore:\r\n```javascript\r\nvar store = haro(null, {key: 'id'});\r\n\r\nstore.setUri('https://api.somedomain.com').then(function (records) {\r\n  console.log(records); // [[$id, {...}], ...]\r\n}, function (arg) {\r\n  console.error(arg[0]); // [body, statusCode]\r\n});\r\n```\r\n\r\nExample of pagination, by specifying `clear`:\r\n```javascript\r\nvar store = haro(null, {key: 'id'});\r\n\r\nstore.setUri('https://api.somedomain.com?page=1').then(function (records) {\r\n  console.log(records); // [[$id, {...}], ...]\r\n}, function (arg) {\r\n  console.log(arg[0]); // [body, statusCode]\r\n});\r\n\r\n// Later, based on user interaction, change the page\r\nstore.setUri('https://api.somedomain.com?page=2', true).then(function (records) {\r\n  console.log(records); // [[$id, {...}], ...]\r\n}, function (arg) {\r\n  console.error(arg[0]); // [body, statusCode]\r\n});\r\n```\r\n\r\n**sort( callbackFn )**\r\n_Array_\r\n\r\nReturns an Array of the DataStore, sorted by `callbackFn`.\r\n\r\nExample of sorting like an `Array`:\r\n```javascript\r\nvar store = haro(null, {index: ['name', 'age']}),\r\n   data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  console.log(store.sort(function (a, b) {\r\n    return a < b ? -1 : (a > b ? 1 : 0);\r\n  })); // [{name: 'Jane Doe', age: 28}, {name: 'John Doe', age: 30}]\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**sortBy( index )**\r\n_Tuple_\r\n\r\nReturns a `Tuple` of double `Tuples` with the shape `[key, value]` of records sorted by an index.\r\n\r\nExample of sorting by an index:\r\n```javascript\r\nvar store = haro(null, {index: ['name', 'age']}),\r\n   data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  console.log(store.sortBy('age')); // [[$uuid, {name: 'Jane Doe', age: 28}], [$uuid, {name: 'John Doe', age: 30}]]\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**sync( clear=false )**\r\n_Promise_\r\n\r\nSynchronises the DataStore with an API collection. If `clear` is `true`, the DataStore will have `clear()` executed\r\nprior to `batch()` upon a successful retrieval of data.\r\n\r\nExample of sorting by an index:\r\n```javascript\r\nvar store = haro(null, {key: 'id'}),\r\n    interval;\r\n\r\nstore.setUri('https://api.somedomain.com').then(function (records) {\r\n  console.log(records); // [[$id, {...}], ...]\r\n}, function (arg) {\r\n  console.error(arg[0]); // [body, statusCode]\r\n});\r\n\r\n// Synchronizing the store every minute\r\ninterval = setInterval(function () {\r\n  store.sync();\r\n}, 60000);\r\n```\r\n\r\n**toArray()**\r\n_Array_\r\n\r\nReturns an Array of the DataStore.\r\n\r\nExample of casting to an `Array`:\r\n```javascript\r\nvar store = haro(),\r\n   data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  console.log(store.toArray()); // [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}]\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**toObject()**\r\n_Object_\r\n\r\nReturns an Object of the DataStore.\r\n\r\nExample of casting to an `Object`:\r\n```javascript\r\nvar store = haro(null, {key: 'guid'}),\r\n   data = [{guid: 'abc', name: 'John Doe', age: 30}, {guid: 'def', name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  console.log(store.toObject()); // {abc: {guid: 'abc', name: 'John Doe', age: 30}, def: {guid: 'def', name: 'Jane Doe', age: 28}}\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n**values()**\r\n_MapIterator_\r\n\r\nReturns a new `Iterator` object that contains the values for each element in the `Map` object in insertion order.\r\n\r\nExample of iterating the values:\r\n```javascript\r\nvar store = haro(),\r\n   data = [{name: 'John Doe', age: 30}, {name: 'Jane Doe', age: 28}];\r\n\r\nstore.batch(data, 'set').then(function (records) {\r\n  var iterator = store.values(),\r\n      item = iterator.next();\r\n\r\n  do {\r\n    console.log(item.value);\r\n    item = iterator.next();\r\n  } while (!item.done);\r\n}, function (e) {\r\n  console.error(e.stack || e.message || e);\r\n});\r\n```\r\n\r\n### Requirements\r\n- `Map`\r\n- `Promise`\r\n- `Set`\r\n- `fetch()`\r\n- `tuple()` see [tiny-tuple](https://github.com/avoidwork/tiny-tuple) for loading in a browser\r\n\r\n## License\r\nCopyright (c) 2015 Jason Mulligan\r\nLicensed under the BSD-3 license\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}